<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Sudoku</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap');

        :root {
            /* Minimalist Palette */
            --bg-color: #f0f4f7; 
            --container-bg: #ffffff;
            --grid-line: #bdc3c7; /* Light Gray */
            --major-grid-line: #34495e; /* Dark Slate Gray */

            /* Number Colors */
            --initial-number-color: #2c3e50; /* Dark Navy - Fixed numbers */
            --user-number-color: #3498db; /* Bright Blue - Confirmed user input */
            --pencil-mark-color: #7f8c8d; /* Subtle Gray - Notes */
            --strong-mark-color: #16a085; /* Teal Green - Strong Notes */
            --error-color: #e74c3c; /* Red - Incorrect input */
            --highlight-number-color: #f39c12; /* Orange - For highlighting selected number */
            --completed-number-bg: #2ecc71; /* Emerald Green */

            /* Cell States */
            --selected-cell-bg: #e0f2f1; /* Light Teal */
            --highlighted-peer-bg: #f8f9fa; /* Very Light Gray */
            --note-highlight-bg: #fdf2e9; /* Off-white for number occurrences */
            --possible-cell-bg: #e5f7e5; /* Very Light Green - For possible input locations */

            /* Controls */
            --control-bg: #ecf0f1; /* Toned Down Gray */
            --control-text: #34495e;
            --control-hover: #bdc3c7;
            --gemini-button-bg: #2ecc71; /* Emerald Green */
            --gemini-button-hover: #27ae60;
            --toggle-on-bg: #3498db; 
            --toggle-on-text: #ffffff; 
            --toggle-off-bg: #ecf0f1;
            --toggle-off-text: #34495e;
            
            --message-box-bg: #fffde7;
            --message-box-border: #f9e79f;
            --message-box-color: #856404;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-color);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }

        .sudoku-container {
            background-color: var(--container-bg);
            border-radius: 16px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.1);
            padding: 30px;
            max-width: 90%;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 24px;
        }

        h1 {
            color: var(--major-grid-line);
            font-weight: 900;
            margin: 0 0 10px;
            text-align: center;
        }

        canvas {
            border: 2px solid var(--major-grid-line);
            border-radius: 8px;
            touch-action: manipulation;
            max-width: 100%;
            height: auto;
        }

        .controls-wrapper {
            width: 100%;
            max-width: 400px;
        }

        .number-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            width: 100%;
        }

        .control-group {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            width: 100%;
            margin-top: 15px;
        }

        .number-button, .control-button {
            padding: 18px 10px;
            font-size: 1.5rem;
            font-weight: 700;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
            white-space: nowrap;
            text-align: center;
        }

        /* Number buttons are subtle */
        .number-button {
            background-color: var(--control-bg);
            color: var(--major-grid-line);
        }

        .number-button:hover:not(.is-completed-correctly) {
            background-color: var(--control-hover);
            transform: translateY(-2px);
        }
        
        .number-button.is-highlighted {
            background-color: var(--highlight-number-color);
            color: white;
            box-shadow: 0 4px 10px rgba(243, 156, 18, 0.4);
        }
        
        .number-button.is-completed-correctly {
            background-color: var(--completed-number-bg);
            color: white;
            box-shadow: 0 4px 10px rgba(46, 204, 113, 0.4);
            font-weight: 900;
        }

        /* Toned Down Control Buttons */
        .control-button {
            background-color: var(--control-bg);
            color: var(--control-text);
            font-size: 1.0rem;
            padding: 12px;
            min-width: 70px; /* Ensure small buttons don't shrink too much */
        }
        
        .control-button:hover:not(:disabled) {
            background-color: var(--control-hover);
            transform: translateY(-2px);
        }
        .control-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Specific styles */
        #hint-button {
            background-color: var(--gemini-button-bg);
            color: white;
        }

        #hint-button:hover:not(:disabled) {
            background-color: var(--gemini-button-hover);
        }

        #mode-button {
            font-size: 1.0rem;
            font-weight: 700;
        }

        .toggle-on {
            background-color: var(--toggle-on-bg) !important;
            color: var(--toggle-on-text) !important;
        }
        
        /* Style for the new Strike Mode (Red/Error color) */
        .strike-mode-on {
            background-color: var(--error-color) !important;
            color: var(--toggle-on-text) !important;
        }

        .message-box {
            background-color: var(--message-box-bg);
            color: var(--message-box-color);
            border: 1px solid var(--message-box-border);
            border-radius: 8px;
            padding: 15px 20px;
            text-align: center;
            font-weight: bold;
            margin-top: 20px;
            max-width: 90%;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
        }

        .message-box.show {
            opacity: 1;
            visibility: visible;
        }

        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid var(--gemini-button-bg);
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: inline-block;
            margin-right: 8px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        @media (min-width: 768px) {
            .sudoku-container {
                flex-direction: row;
                justify-content: space-between;
                align-items: flex-start;
                gap: 50px;
            }

            .game-board {
                width: 450px;
            }
        }
    </style>
</head>
<body>
    <div class="sudoku-container">
        <div class="game-board">
            <h1>Sudoku</h1>
            <canvas id="sudoku-canvas"></canvas>
        </div>
        <div class="controls-wrapper">
            <div class="number-buttons">
                <button class="number-button" data-value="1">1</button>
                <button class="number-button" data-value="2">2</button>
                <button class="number-button" data-value="3">3</button>
                <button class="number-button" data-value="4">4</button>
                <button class="number-button" data-value="5">5</button>
                <button class="number-button" data-value="6">6</button>
                <button class="number-button" data-value="7">7</button>
                <button class="number-button" data-value="8">8</button>
                <button class="number-button" data-value="9">9</button>
            </div>
            
            <div class="control-group">
                <button id="mode-button" class="control-button" style="grid-column: 1 / span 3;">
                    ‚úèÔ∏è Value Mode
                </button>
            </div>

            <div class="control-group">
                <button id="undo-button" class="control-button" disabled>‚Ü©Ô∏è</button>
                <button id="clear-button" class="control-button">‚ùå Erase</button>
                <button id="recover-board-button" class="control-button">üè† Reset</button>
            </div>

            <div class="control-group">
                <button id="auto-mark-button" class="control-button">üìù Auto Notes</button>
                <button id="new-game-button" class="control-button">üÜï Game</button>
                <button id="solve-button" class="control-button">üîÆ Solve</button>
            </div>

            <div class="control-group" style="margin-top: 25px;">
                <button id="hint-button" class="control-button" style="grid-column: 1 / span 3;">
                    <span id="hint-text">‚ú® Smart Hint</span>
                </button>
            </div>

        </div>
    </div>
    <div id="message-box" class="message-box"></div>

    <script>
        window.onload = function() {
            const canvas = document.getElementById('sudoku-canvas');
            const ctx = canvas.getContext('2d');
            const numberButtons = document.querySelectorAll('.number-button');
            const clearButton = document.getElementById('clear-button');
            const newGameButton = document.getElementById('new-game-button');
            const solveButton = document.getElementById('solve-button');
            const hintButton = document.getElementById('hint-button');
            const hintText = document.getElementById('hint-text');
            const modeButton = document.getElementById('mode-button');
            const undoButton = document.getElementById('undo-button');
            const recoverBoardButton = document.getElementById('recover-board-button');
            const autoMarkButton = document.getElementById('auto-mark-button');
            const messageBox = document.getElementById('message-box');

            const boardSize = 9;
            let initialBoard = []; 
            // Cell structure: { value: number (0-9), cornerNotes: Set<number>, centerNotes: Set<number> }
            let currentBoard = []; 
            let solutionBoard = [];
            let selectedCells = []; // Updated to array for multi-selection
            let cellSize;
            // Mode: 'value', 'corner', 'center', 'strike'
            let currentMode = 'value'; 
            let highlightNumber = null; // The number being highlighted (1-9)

            // --- History Implementation ---
            let boardHistory = [];
            const MAX_HISTORY = 30;

            function pushHistory() {
                if (!currentBoard.length) return;
                
                // Save the state BEFORE the move
                const stateClone = currentBoard.map(row => 
                    row.map(cell => ({
                        value: cell.value,
                        cornerNotes: new Set(cell.cornerNotes),
                        centerNotes: new Set(cell.centerNotes),
                    }))
                );
                
                boardHistory.push(stateClone);
                if (boardHistory.length > MAX_HISTORY) {
                    boardHistory.shift(); 
                }
                updateUndoButtonState();
            }
            
            function undoLastMove() {
                if (boardHistory.length > 1) {
                    boardHistory.pop(); // Remove the current state 
                    const prevState = boardHistory[boardHistory.length - 1]; // Get the state before the undone move
                    
                    currentBoard = prevState.map(row => 
                        row.map(cell => ({
                            value: cell.value,
                            cornerNotes: new Set(cell.cornerNotes),
                            centerNotes: new Set(cell.centerNotes),
                        }))
                    );

                    selectedCells = []; // Clear selection after undo
                    highlightNumber = null; // Clear number highlight
                    
                    drawBoard();
                    showMessage('Move undone.', 2000);
                }
                updateUndoButtonState();
            }

            function updateUndoButtonState() {
                // Button is only enabled if there is a state BEFORE the current state to return to.
                // Length > 1 means the initial state + at least one user action has been recorded.
                undoButton.disabled = boardHistory.length <= 1; 
            }
            // --- End History Implementation ---


            // --- Gemini API Setup ---
            const apiKey = ""; 
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;

            async function exponentialBackoffFetch(url, options, maxRetries = 5) {
                for (let attempt = 0; attempt < maxRetries; attempt++) {
                    try {
                        const response = await fetch(url, options);
                        if (response.status !== 429) {
                            return response;
                        }
                    } catch (error) {
                        // Network error, try again after delay
                    }

                    if (attempt < maxRetries - 1) {
                        const delay = Math.pow(2, attempt) * 1000 + Math.random() * 1000;
                        await new Promise(resolve => setTimeout(resolve, delay));
                    }
                }
                throw new Error("API request failed after multiple retries.");
            }

            function formatBoardForLLM() {
                let boardString = "";
                for (let r = 0; r < 9; r++) {
                    for (let c = 0; c < 9; c++) {
                        boardString += currentBoard[r][c].value.toString();
                    }
                }
                return boardString;
            }

            async function getSudokuHint() {
                hintButton.disabled = true;
                hintText.innerHTML = '<span class="loading-spinner"></span> Analyzing...';
                showMessage('Requesting Smart Hint from Gemini...', 60000);

                const boardString = formatBoardForLLM();
                
                const systemPrompt = `You are a world-class Sudoku tutor. Analyze the following 81-digit Sudoku puzzle (0 represents an empty cell). Identify the single best, simplest next move (e.g., Naked Single, Hidden Single, Pointing Pair). DO NOT solve the puzzle completely. Just explain the logic for the next move and state the location (Row X, Column Y) and the number. Provide a concise, friendly response.`;

                const userQuery = `Current Sudoku Board (Row by Row, 0 for empty): ${boardString}`;

                const payload = {
                    contents: [{ parts: [{ text: userQuery }] }],
                    systemInstruction: {
                        parts: [{ text: systemPrompt }]
                    },
                };

                try {
                    const response = await exponentialBackoffFetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    const result = await response.json();
                    const text = result.candidates?.[0]?.content?.parts?.[0]?.text || "Sorry, I couldn't find a hint right now. Try another move or reset.";
                    showMessage(`‚ú® **Hint:** ${text}`, 8000);

                } catch (error) {
                    console.error("Gemini API Error:", error);
                    showMessage('Error: Could not retrieve a hint. Please check the console.', 5000);
                } finally {
                    hintButton.disabled = false;
                    hintText.textContent = '‚ú® Smart Hint';
                }
            }
            // --- End Gemini API Setup ---

            // Puzzle generation/solving (Unchanged)
            function generateAndSolve() {
                const puzzle = createPuzzle();
                initialBoard = puzzle.initial;
                solutionBoard = puzzle.solution;

                currentBoard = initialBoard.map(row => 
                    row.map(value => ({
                        value: value,
                        cornerNotes: new Set(),
                        centerNotes: new Set(),
                    }))
                );
                
                boardHistory = [];
                pushHistory(); 
                
                drawBoard();
                showMessage('New puzzle generated!', 3000);
            }

            function createPuzzle() { 
                const grid = Array(9).fill(null).map(() => Array(9).fill(0));
                fillGrid(grid);
                const solution = JSON.parse(JSON.stringify(grid));
                const initial = JSON.parse(JSON.stringify(grid));
                let holes = 45; 
                while (holes > 0) {
                    const row = Math.floor(Math.random() * 9);
                    const col = Math.floor(Math.random() * 9);
                    if (initial[row][col] !== 0) {
                        initial[row][col] = 0;
                        holes--;
                    }
                }
                return { initial, solution };
            }

            function fillGrid(grid) {
                for (let row = 0; row < 9; row++) {
                    for (let col = 0; col < 9; col++) {
                        if (grid[row][col] === 0) {
                            const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9].sort(() => Math.random() - 0.5);
                            for (const num of numbers) {
                                if (isValid(grid, row, col, num)) {
                                    grid[row][col] = num;
                                    if (fillGrid(grid)) {
                                        return true;
                                    } else {
                                        grid[row][col] = 0;
                                    }
                                }
                            }
                            return false;
                        }
                    }
                }
                return true;
            }

            function isValid(grid, row, col, num) {
                for (let i = 0; i < 9; i++) {
                    if (grid[row][i] === num || grid[i][col] === num) {
                        return false;
                    }
                }
                const startRow = Math.floor(row / 3) * 3;
                const startCol = Math.floor(col / 3) * 3;
                for (let i = 0; i < 3; i++) {
                    for (let j = 0; j < 3; j++) {
                        if (grid[startRow + i][startCol + j] === num) {
                            return false;
                        }
                    }
                }
                return true;
            }
            // End puzzle generation/solving

            // --- Core Logic ---

            function autoEliminateCandidates(row, col, num) {
                // Clear num from notes in the same row, column, and block
                for (let i = 0; i < 9; i++) {
                    currentBoard[row][i].cornerNotes.delete(num); // Row
                    currentBoard[row][i].centerNotes.delete(num); // Row
                    currentBoard[i][col].cornerNotes.delete(num); // Column
                    currentBoard[i][col].centerNotes.delete(num); // Column
                }

                const startRow = Math.floor(row / 3) * 3;
                const startCol = Math.floor(col / 3) * 3;
                for (let i = 0; i < 3; i++) {
                    for (let j = 0; j < 3; j++) {
                        currentBoard[startRow + i][startCol + j].cornerNotes.delete(num); // Block
                        currentBoard[startRow + i][startCol + j].centerNotes.delete(num); // Block
                    }
                }
            }

            function isNumberCompleteAndCorrect(num) {
                let count = 0;
                for (let row = 0; row < 9; row++) {
                    for (let col = 0; col < 9; col++) {
                        if (solutionBoard[row][col] === num) {
                            if (currentBoard[row][col].value !== num) {
                                return false; 
                            }
                            count++;
                        }
                    }
                }
                return count === 9; 
            }

            function isSafeForCurrentBoard(board, row, col, num) {
                // Check row and column for existing definitive values
                for (let i = 0; i < 9; i++) {
                    if (board[row][i].value === num || board[i][col].value === num) {
                        return false;
                    }
                }
                // Check block
                const startRow = Math.floor(row / 3) * 3;
                const startCol = Math.floor(col / 3) * 3;
                for (let i = 0; i < 3; i++) {
                    for (let j = 0; j < 3; j++) {
                        if (board[startRow + i][startCol + j].value === num) {
                            return false;
                        }
                    }
                }
                return true;
            }

            // --- Auto Pencil Mark ---
            function autoFillAllCandidates() {
                pushHistory();
                
                for (let r = 0; r < 9; r++) {
                    for (let c = 0; c < 9; c++) {
                        const cell = currentBoard[r][c];
                        // Only fill candidates if the cell is empty and user-editable
                        if (cell.value === 0 && initialBoard[r][c] === 0) {
                            cell.cornerNotes.clear();
                            cell.centerNotes.clear();
                            
                            for (let num = 1; num <= 9; num++) {
                                if (isSafeForCurrentBoard(currentBoard, r, c, num)) {
                                    cell.cornerNotes.add(num);
                                }
                            }
                        }
                    }
                }
                drawBoard();
                showMessage('All possible candidates have been auto-marked.', 3000);
            }


            // --- Draw Logic (Unchanged) ---

            function drawBoard() {
                const padding = 10;
                const canvasSize = Math.min(window.innerWidth * 0.8, window.innerHeight * 0.7, 450);
                canvas.width = canvasSize;
                canvas.height = canvasSize;
                cellSize = (canvas.width - 2 * padding) / 9;

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                updateNumberButtonVisuals();

                ctx.fillStyle = varColor('--container-bg');
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const possibleCells = [];
                if (highlightNumber) {
                    for(let r = 0; r < 9; r++) {
                        for(let c = 0; c < 9; c++) {
                            if (currentBoard[r][c].value === 0 && initialBoard[r][c] === 0 && isSafeForCurrentBoard(currentBoard, r, c, highlightNumber)) {
                                possibleCells.push({r, c});
                            }
                        }
                    }
                }


                for (let row = 0; row < boardSize; row++) {
                    for (let col = 0; col < boardSize; col++) {
                        let cellBg = varColor('--container-bg');

                        // 1. Highlight peers (row, column, block) of selected cells (Multi-select update)
                        if (selectedCells.some(selected => 
                           (selected.row === row || selected.col === col || 
                            (Math.floor(selected.row / 3) === Math.floor(row / 3) && 
                             Math.floor(selected.col / 3) === Math.floor(col / 3))))) {
                            cellBg = varColor('--highlighted-peer-bg');
                        }
                        
                        // 2. Highlight POSSIBLE cell locations
                        if (highlightNumber && possibleCells.some(p => p.r === row && p.c === col)) {
                            if (currentBoard[row][col].value === 0) {
                                cellBg = varColor('--possible-cell-bg');
                            }
                        }


                        // 3. Highlight cells containing the number (if number highlighting is active)
                        const cell = currentBoard[row][col];
                        const cellValue = cell.value;

                        // Only apply note highlight if not selected and the number is present
                        if (highlightNumber && (cellValue === highlightNumber || cell.cornerNotes.has(highlightNumber) || cell.centerNotes.has(highlightNumber))) {
                            if (!selectedCells.some(selected => selected.row === row && selected.col === col)) {
                                cellBg = varColor('--note-highlight-bg'); 
                            }
                        }

                        // 4. Selected Cells take precedence
                        if (selectedCells.some(selected => selected.row === row && selected.col === col)) {
                            cellBg = varColor('--selected-cell-bg');
                        }


                        ctx.fillStyle = cellBg;
                        ctx.fillRect(padding + col * cellSize, padding + row * cellSize, cellSize, cellSize);
                    }
                }

                // Draw Numbers and Pencil Markings (Unchanged)
                for (let row = 0; row < boardSize; row++) {
                    for (let col = 0; col < boardSize; col++) {
                        const cell = currentBoard[row][col];
                        const initialValue = initialBoard[row][col];

                        if (cell.value !== 0) {
                            if (initialValue !== 0) {
                                ctx.fillStyle = varColor('--initial-number-color');
                            } else {
                                ctx.fillStyle = varColor('--user-number-color');
                            }
                            
                            ctx.font = `bold ${cellSize * 0.6}px Inter`;
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText(cell.value, 
                                padding + col * cellSize + cellSize / 2, 
                                padding + row * cellSize + cellSize / 2
                            );
                        } 
                        else if (cell.cornerNotes.size > 0) {
                            const noteSize = cellSize / 3;
                            ctx.fillStyle = varColor('--pencil-mark-color');
                            ctx.font = `${cellSize * 0.25}px Inter`; 
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            
                            cell.cornerNotes.forEach(note => {
                                const noteIndex = note - 1;
                                const noteRow = Math.floor(noteIndex / 3);
                                const noteCol = noteIndex % 3;
                                
                                const x = padding + col * cellSize + (noteCol * noteSize) + noteSize / 2;
                                const y = padding + row * cellSize + (noteRow * noteSize) + noteSize / 2;
                                
                                ctx.fillText(note, x, y);
                            });
                        }
                        
                        if (cell.centerNotes.size > 0) {
                            const noteList = Array.from(cell.centerNotes).sort();
                            const noteText = noteList.join(' ');
                            
                            ctx.fillStyle = varColor('--strong-mark-color');
                            ctx.font = `bold ${cellSize * 0.35}px Inter`; 
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            
                            const x = padding + col * cellSize + cellSize / 2;
                            const y = padding + row * cellSize + cellSize / 2;
                            
                            ctx.fillText(noteText, x, y);
                        }
                    }
                }

                // Draw grid lines (Unchanged)
                ctx.strokeStyle = varColor('--grid-line');
                ctx.lineWidth = 1;
                for (let i = 0; i <= boardSize; i++) {
                    ctx.beginPath();
                    ctx.moveTo(padding, padding + i * cellSize);
                    ctx.lineTo(canvas.width - padding, padding + i * cellSize);
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(padding + i * cellSize, padding);
                    ctx.lineTo(padding + i * cellSize, canvas.height - padding);
                    ctx.stroke();
                }

                ctx.strokeStyle = varColor('--major-grid-line');
                ctx.lineWidth = 3;
                for (let i = 0; i <= 3; i++) {
                    ctx.beginPath();
                    ctx.moveTo(padding, padding + i * 3 * cellSize);
                    ctx.lineTo(canvas.width - padding, padding + i * 3 * cellSize);
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(padding + i * 3 * cellSize, padding);
                    ctx.lineTo(padding + i * 3 * cellSize, canvas.height - padding);
                    ctx.stroke();
                }
            }

            function varColor(variable) {
                return getComputedStyle(document.documentElement).getPropertyValue(variable);
            }

            function updateNumberButtonVisuals() {
                numberButtons.forEach(button => {
                    const num = parseInt(button.dataset.value);
                    button.classList.remove('is-completed-correctly');
                    
                    if (isNumberCompleteAndCorrect(num)) {
                        button.classList.add('is-completed-correctly');
                    }
                });
            }

            // --- Multi-Cell Selection (Unchanged) ---
            function handleCanvasClick(event) {
                const rect = canvas.getBoundingClientRect();
                const x = (event.touches ? event.touches[0].clientX : event.clientX) - rect.left;
                const y = (event.touches ? event.touches[0].clientY : event.clientY) - rect.top;
                const padding = 10;
                
                const col = Math.floor((x - padding) / cellSize);
                const row = Math.floor((y - padding) / cellSize);

                if (row >= 0 && row < 9 && col >= 0 && col < 9) {
                    // Check for multi-select modifier key (Shift, Ctrl, or Cmd)
                    const isMultiSelect = event.shiftKey || event.ctrlKey || event.metaKey; 
                    const cellInfo = { row, col };
                    // Helper to check if a cell is already selected
                    const index = selectedCells.findIndex(cell => cell.row === row && cell.col === col);

                    if (!isMultiSelect) {
                        // Single select: Clear previous selections unless the same cell is clicked.
                        selectedCells = (index === 0 && selectedCells.length === 1) ? [] : [cellInfo];
                    } else {
                        // Multi-select: Toggle selection
                        if (index !== -1) {
                            selectedCells.splice(index, 1); // Deselect
                        } else {
                            selectedCells.push(cellInfo); // Select
                        }
                    }
                    
                    highlightNumber = null; 
                    updateNumberButtonHighlights();
                    drawBoard();
                }
            }
            
            function updateNumberButtonHighlights(num = null) {
                numberButtons.forEach(btn => btn.classList.remove('is-highlighted'));
                if (num) {
                    document.querySelector(`.number-button[data-value="${num}"]`).classList.add('is-highlighted');
                }
            }

            function handleNumberInput(value) {
                const num = parseInt(value);

                // Highlight/Un-highlight number if no cell is selected
                if (selectedCells.length === 0) {
                    if (highlightNumber === num) {
                        highlightNumber = null;
                    } else {
                        highlightNumber = num;
                    }
                    updateNumberButtonHighlights(highlightNumber);
                    drawBoard();
                    return;
                }
                
                // Apply input to all selected cells
                pushHistory(); // Save the state BEFORE the move

                selectedCells.forEach(({ row, col }) => {
                    const cell = currentBoard[row][col];

                    if (initialBoard[row][col] !== 0) {
                        return; // Skip fixed cells
                    }

                    if (currentMode === 'value') {
                        // --- Value Mode: Set final answer ---
                        if (cell.value === num) {
                            cell.value = 0; 
                        } else {
                            cell.value = num;
                            cell.cornerNotes.clear(); 
                            cell.centerNotes.clear(); 
                            autoEliminateCandidates(row, col, num); 
                        }
                    } else if (currentMode === 'corner') {
                        // --- Corner Note Mode: Toggle Pencil Marks ---
                        if (cell.value !== 0) cell.value = 0; 

                        if (cell.cornerNotes.has(num)) {
                            cell.cornerNotes.delete(num);
                        } else {
                            cell.cornerNotes.add(num);
                            cell.centerNotes.delete(num); 
                        }

                    } else if (currentMode === 'center') {
                        // --- Center Mark Mode: Toggle Strong Candidates ---
                        if (cell.value !== 0) cell.value = 0; 

                        if (cell.centerNotes.has(num)) {
                            cell.centerNotes.delete(num);
                        } else {
                            cell.centerNotes.add(num);
                            cell.cornerNotes.delete(num); 
                        }
                    } else if (currentMode === 'strike') {
                        // --- Strike Mode: Manually Eliminate Notes ---
                        // Remove the candidate from both note types
                        cell.cornerNotes.delete(num);
                        cell.centerNotes.delete(num);
                        // Ensure the cell is clear of final values
                        if (cell.value === num) {
                            cell.value = 0;
                        }
                    }
                });
                
                checkWinCondition();
                drawBoard();
            }

            // --- Group Clear ---
            function clearSelectedCell() {
                if (selectedCells.length === 0) {
                    showMessage('Please select one or more cells first.', 3000);
                    return;
                }
                pushHistory();
                selectedCells.forEach(({ row, col }) => {
                    const cell = currentBoard[row][col];
                    if (initialBoard[row][col] === 0) {
                        cell.value = 0;
                        cell.cornerNotes.clear();
                        cell.centerNotes.clear();
                    }
                });
                drawBoard();
            }

            function solvePuzzle() {
                pushHistory();
                currentBoard = solutionBoard.map(row => 
                    row.map(value => ({
                        value: value,
                        cornerNotes: new Set(),
                        centerNotes: new Set(),
                    }))
                );
                drawBoard();
                showMessage('Puzzle solved!', 3000);
            }

            function checkWinCondition() {
                for (let row = 0; row < 9; row++) {
                    for (let col = 0; col < 9; col++) {
                        if (currentBoard[row][col].value !== solutionBoard[row][col]) {
                            return false;
                        }
                    }
                }
                showMessage('üåü Congratulations! You solved the puzzle!', 5000);
                return true;
            }

            function toggleMarkingMode() {
                // Remove all previous mode classes
                modeButton.classList.remove('toggle-on', 'strike-mode-on');
                modeButton.style.backgroundColor = varColor('--control-bg');
                modeButton.style.color = varColor('--control-text');

                if (currentMode === 'value') {
                    currentMode = 'corner';
                    modeButton.textContent = '‚úçÔ∏è Corner Note Mode';
                    modeButton.classList.add('toggle-on');
                    modeButton.style.backgroundColor = varColor('--toggle-on-bg');
                    modeButton.style.color = varColor('--toggle-on-text');
                    showMessage('Corner Note Mode: Input numbers are small corner notes.', 3000);

                } else if (currentMode === 'corner') {
                    currentMode = 'center';
                    modeButton.textContent = '‚≠ê Center Mark Mode';
                    modeButton.classList.add('toggle-on');
                    modeButton.style.backgroundColor = varColor('--strong-mark-color');
                    modeButton.style.color = varColor('--toggle-on-text');
                    showMessage('Center Mark Mode: Input numbers are bold center candidates.', 3000);

                } else if (currentMode === 'center') {
                    currentMode = 'strike';
                    modeButton.textContent = 'üö´ Strike Mode';
                    modeButton.classList.add('strike-mode-on');
                    modeButton.style.backgroundColor = varColor('--error-color');
                    modeButton.style.color = varColor('--toggle-on-text');
                    showMessage('Strike Mode: Use numbers to manually delete notes/candidates from selected cells.', 3000);

                } else {
                    currentMode = 'value';
                    modeButton.textContent = '‚úèÔ∏è Value Mode';
                    showMessage('Value Mode: Input numbers are final answers.', 3000);
                }
                
                selectedCells = []; // Deselect cells when changing mode
                drawBoard();
            }
            
            function recoverBoard() {
                pushHistory();
                currentBoard = initialBoard.map((row, r) => 
                    row.map((value, c) => ({
                        value: value,
                        cornerNotes: new Set(),
                        centerNotes: new Set(),
                    }))
                );
                drawBoard();
                showMessage('Board recovered to the original starting puzzle state (solvable).', 3000);
            }


            let messageTimeout;
            function showMessage(message, duration) {
                clearTimeout(messageTimeout);
                messageBox.innerHTML = message;
                messageBox.classList.add('show');
                messageTimeout = setTimeout(() => {
                    messageBox.classList.remove('show');
                }, duration);
            }

            // Event Listeners
            canvas.addEventListener('mousedown', handleCanvasClick);
            // Added support for touch events, ensuring multi-select is off for touch
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                // Clone the event and suppress modifier keys for touch
                handleCanvasClick({
                    clientX: e.touches[0].clientX,
                    clientY: e.touches[0].clientY,
                    shiftKey: false, 
                    ctrlKey: false,
                    metaKey: false,
                    preventDefault: () => {}
                });
            });

            numberButtons.forEach(button => {
                button.addEventListener('click', () => {
                    handleNumberInput(button.dataset.value);
                });
            });

            clearButton.addEventListener('click', clearSelectedCell);
            newGameButton.addEventListener('click', generateAndSolve);
            solveButton.addEventListener('click', solvePuzzle);
            hintButton.addEventListener('click', getSudokuHint);
            
            modeButton.addEventListener('click', toggleMarkingMode);
            recoverBoardButton.addEventListener('click', recoverBoard);
            undoButton.addEventListener('click', undoLastMove);
            autoMarkButton.addEventListener('click', autoFillAllCandidates); // New listener for auto-mark

            // Responsive design: redraw board on window resize
            window.addEventListener('resize', drawBoard);

            // Initial setup
            generateAndSolve();
        };
    </script>
</body>
</html>
